// Generated by CoffeeScript 1.10.0
(function() {
  var _condCompile, compare, compareFunc, condCompile, getFuncByCondStr, memoize,
    slice = [].slice;

  memoize = function(func) {
    var addressArr, cache, config;
    cache = {};
    config = require('./memoize.config');
    addressArr = [];
    setInterval(function() {
      var address, results;
      results = [];
      while (addressArr.length > config.cache_keys_max) {
        address = addressArr.shift();
        results.push(delete cache[address]);
      }
      return results;
    }, config.cache_keys_max);
    return function() {
      var address, args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      address = args.join('#@$@#$');
      if (!cache.hasOwnProperty(address)) {
        cache[address] = func.apply(this, args);
        addressArr.push(address);
      }
      return cache[address];
    };
  };

  compareFunc = (function() {
    return {
      eq: function(a, b) {
        return a === b;
      },
      ne: function(a, b) {
        return a !== b;
      },
      gt: function(a, b) {
        return a > b;
      },
      gte: function(a, b) {
        return a >= b;
      },
      lt: function(a, b) {
        return a < b;
      },
      lte: function(a, b) {
        return a <= b;
      },
      like: function(a, b) {
        return this.test(a, b);
      },
      not_like: function(a, b) {
        return !this.like(a, b);
      },
      test: function(a, b) {
        return b.test(a);
      }
    };
  })();

  getFuncByCondStr = function(str) {
    var funcGenArr, gen, genCommonFunc, genEq, genLikeReg, i, len, likePercentReg, signNeedEscapeReg;
    likePercentReg = /([^\\])%|^%/g;
    signNeedEscapeReg = /\.|\+|\?|\*|\:|\!|\[|\]|\(\|\)|\^|\$|\{|\}|\=/g;
    genLikeReg = function(str) {
      str = str.replace(signNeedEscapeReg, function($1) {
        return "\\" + $1;
      }).replace(likePercentReg, function($0, $1) {
        if ($1 == null) {
          $1 = '';
        }
        return $1 + '.*';
      });
      str = '^' + str + '$';
      return new RegExp(str);
    };
    genCommonFunc = function(methodName, _reg) {
      return function(str, reg) {
        var cond;
        reg = _reg || reg;
        cond = str.replace(reg, '');
        return function(value) {
          return compareFunc[methodName](value, cond);
        };
      };
    };
    funcGenArr = [
      {
        reg: /^=|^\+/,
        getFunc: function(str) {
          var cond, reg;
          if (str == null) {
            str = '';
          }
          cond = str.replace(this.reg, '');
          if (likePercentReg.test(cond)) {
            reg = genLikeReg(cond);
            return function(value) {
              return compareFunc.like(value, reg);
            };
          } else {
            return function(value) {
              return compareFunc.eq(value, cond);
            };
          }
        }
      }, {
        reg: /^-|^<>/,
        getFunc: function(str) {
          var cond, reg;
          if (str == null) {
            str = '';
          }
          cond = str.replace(this.reg, '');
          if (likePercentReg.test(cond)) {
            reg = genLikeReg(cond);
            return function(value) {
              return compareFunc.not_like(value, reg);
            };
          } else {
            return function(value) {
              return compareFunc.ne(value, cond);
            };
          }
        }
      }, {
        reg: /^>[^=]/,
        getFunc: genCommonFunc('gt', /^>/)
      }, {
        reg: /^>=/,
        getFunc: genCommonFunc('gte')
      }, {
        reg: /^<[^=]/,
        getFunc: genCommonFunc('lt', /^</)
      }, {
        reg: /^<=/,
        getFunc: genCommonFunc('lte')
      }, {
        reg: /^\/(.*)\/$/,
        getFunc: function(str) {
          var reg;
          reg = eval(str);
          return function(value) {
            return compareFunc.test(value, reg);
          };
        }
      }
    ];
    for (i = 0, len = funcGenArr.length; i < len; i++) {
      gen = funcGenArr[i];
      if (gen.reg.test(str)) {
        return gen.getFunc(str, gen.reg);
      }
    }
    genEq = funcGenArr[0];
    return genEq.getFunc(str, gen.reg);
  };

  _condCompile = function(str) {
    var andSplit, andStr, i, j, len, len1, orArr, orSplit, orStr, ref, ref1, ret;
    orSplit = ';';
    andSplit = ',';
    ret = [];
    str = str.replace(/\r|\n/g, '');
    ref = str.split(orSplit);
    for (i = 0, len = ref.length; i < len; i++) {
      orStr = ref[i];
      orArr = [];
      ref1 = orStr.split(andSplit);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        andStr = ref1[j];
        andStr = andStr.replace(/^[\s]+/g, '').replace(/[\s]+$/g, '');
        orArr.push(getFuncByCondStr(andStr));
      }
      ret.push(orArr);
    }
    return ret;
  };

  condCompile = memoize(_condCompile);

  compare = function(str, condStr, ifFuncCache) {
    var andArr, andFuc, b, condArr, i, j, len, len1, orRet, ret;
    if (ifFuncCache == null) {
      ifFuncCache = true;
    }
    if (ifFuncCache) {
      condArr = condCompile(condStr);
    } else {
      condArr = _condCompile(condStr);
    }
    ret = false;
    for (i = 0, len = condArr.length; i < len; i++) {
      andArr = condArr[i];
      orRet = true;
      for (j = 0, len1 = andArr.length; j < len1; j++) {
        andFuc = andArr[j];
        b = andFuc(str);
        if (!b) {
          orRet = false;
          break;
        }
      }
      if (orRet) {
        ret = true;
        break;
      }
    }
    return ret;
  };

  module.exports = {
    compare: compare,
    compile: condCompile
  };

}).call(this);

//# sourceMappingURL=index.js.map
