// Generated by CoffeeScript 1.10.0
(function() {
  var _condCompile, compare, compareFunc, condCompile, getFuncByCondStr, memoize, test,
    slice = [].slice;

  memoize = function(func) {
    var addressArr, cache, maxLen;
    cache = {};
    addressArr = [];
    maxLen = 10000;
    setInterval(function() {
      var address, results;
      results = [];
      while (addressArr.length > maxLen) {
        address = addressArr.shift();
        results.push(delete cache[address]);
      }
      return results;
    }, 60 * 60 * 1000);
    return function() {
      var address, args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      address = args.join('_');
      if (!cache.hasOwnProperty(address)) {
        cache[address] = func.apply(this, args);
        addressArr.push(address);
      }
      return cache[address];
    };
  };

  compareFunc = (function() {
    return {
      eq: function(a, b) {
        return a === b;
      },
      ne: function(a, b) {
        return a !== b;
      },
      gt: function(a, b) {
        return a > b;
      },
      gte: function(a, b) {
        return a >= b;
      },
      lt: function(a, b) {
        return a < b;
      },
      lte: function(a, b) {
        return a <= b;
      },
      like: function(a, b) {
        return this.test(a, b);
      },
      not_like: function(a, b) {
        return !this.like(a, b);
      },
      test: function(a, b) {
        return b.test(a);
      }
    };
  })();

  getFuncByCondStr = function(str) {
    var funcGenArr, gen, genCommonFunc, genEq, genLikeReg, j, len, likePercentReg, signNeedEscapeReg;
    likePercentReg = /([^\\])%|^%/g;
    signNeedEscapeReg = /\.|\+|\?|\*|\:|\!|\[|\]|\(\|\)|\^|\$|\{|\}|\=/g;
    genLikeReg = function(str) {
      str = str.replace(signNeedEscapeReg, function($1) {
        return "\\" + $1;
      }).replace(likePercentReg, function($0, $1) {
        if ($1 == null) {
          $1 = '';
        }
        return $1 + '.*';
      });
      str = '^' + str + '$';
      return new RegExp(str);
    };
    genCommonFunc = function(methodName, _reg) {
      return function(str, reg) {
        var cond;
        reg = _reg || reg;
        cond = str.replace(reg, '');
        return function(value) {
          return compareFunc[methodName](value, cond);
        };
      };
    };
    funcGenArr = [
      {
        reg: /^=|^\+/,
        getFunc: function(str) {
          var cond, reg;
          if (str == null) {
            str = '';
          }
          cond = str.replace(this.reg, '');
          if (likePercentReg.test(cond)) {
            reg = genLikeReg(cond);
            return function(value) {
              return compareFunc.like(value, reg);
            };
          } else {
            return function(value) {
              return compareFunc.eq(value, cond);
            };
          }
        }
      }, {
        reg: /^-|^<>/,
        getFunc: function(str) {
          var cond, reg;
          if (str == null) {
            str = '';
          }
          cond = str.replace(this.reg, '');
          if (likePercentReg.test(cond)) {
            reg = genLikeReg(cond);
            return function(value) {
              return compareFunc.not_like(value, reg);
            };
          } else {
            return function(value) {
              return compareFunc.ne(value, cond);
            };
          }
        }
      }, {
        reg: /^>[^=]/,
        getFunc: genCommonFunc('gt', /^>/)
      }, {
        reg: /^>=/,
        getFunc: genCommonFunc('gte')
      }, {
        reg: /^<[^=]/,
        getFunc: genCommonFunc('lt', /^</)
      }, {
        reg: /^<=/,
        getFunc: genCommonFunc('lte')
      }, {
        reg: /^\/(.*)\/$/,
        getFunc: function(str) {
          var reg;
          reg = eval(str);
          return function(value) {
            return compareFunc.test(value, reg);
          };
        }
      }
    ];
    for (j = 0, len = funcGenArr.length; j < len; j++) {
      gen = funcGenArr[j];
      if (gen.reg.test(str)) {
        return gen.getFunc(str, gen.reg);
      }
    }
    genEq = funcGenArr[0];
    return genEq.getFunc(str, gen.reg);
  };

  _condCompile = function(str) {
    var andSplit, andStr, j, k, len, len1, orArr, orSplit, orStr, ref, ref1, ret;
    orSplit = ';';
    andSplit = ',';
    ret = [];
    str = str.replace(/\r|\n/g, '');
    ref = str.split(orSplit);
    for (j = 0, len = ref.length; j < len; j++) {
      orStr = ref[j];
      orArr = [];
      ref1 = orStr.split(andSplit);
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        andStr = ref1[k];
        andStr = andStr.replace(/^[\s]+/g, '').replace(/[\s]+$/g, '');
        orArr.push(getFuncByCondStr(andStr));
      }
      ret.push(orArr);
    }
    return ret;
  };

  condCompile = memoize(_condCompile);

  compare = function(str, condStr, ifFuncCache) {
    var andArr, andFuc, b, condArr, j, k, len, len1, orRet, ret;
    if (ifFuncCache == null) {
      ifFuncCache = true;
    }
    if (ifFuncCache) {
      condArr = condCompile(condStr);
    } else {
      condArr = _condCompile(condStr);
    }
    ret = false;
    for (j = 0, len = condArr.length; j < len; j++) {
      andArr = condArr[j];
      orRet = true;
      for (k = 0, len1 = andArr.length; k < len1; k++) {
        andFuc = andArr[k];
        b = andFuc(str);
        if (!b) {
          orRet = false;
          break;
        }
      }
      if (orRet) {
        ret = true;
        break;
      }
    }
    return ret;
  };

  module.exports = {
    compare: compare,
    compile: condCompile
  };

  test = function() {
    var d0, d1, d2, i, j, k, l, len, len1, len2, m, n, ret, str, t, testArr, value;
    testArr = [['', '', true], ['abc', '', false], ['abc', '+abc', true], ['abcd', '+abc', false], ['abc', '+abcd', false], ['abc', '=abc', true], ['abc', '=abcd', false], ['abcd', '=abc', false], ['abc', '<>abc', false], ['abc', '<>abcd', true], ['abc', '-abc', false], ['abc', '-abcd', true], ['abc', '>abc', false], ['2', '>1', true], ['2', '>1.1', true], ['abc', '>=abc', true], ['2', '>=1', true], ['abc', '<abc', false], ['abc', '<abcd', true], ['1', '<2', true], ['abc', '<=abc', true], ['abc', '<=abcd', true], ['1.3.1', '=1.%.1', true], ['1.3.1', '=%1.3', false], ['1.3.1', '-1.%.1', false], ['1.3.12', '+1.3.1%', true], ['1.1', '/1.*1/', true], ['1.1', '/2\\.1/', false], ['abc', '=abcd,>bcd;=bcd;=abcd;/abcd/;=ab%;', true], ['abc', '=abcd;=bcd;=abcd;/a.*c/;=ab%d;', true]];
    for (j = 0, len = testArr.length; j < len; j++) {
      t = testArr[j];
      str = t[0];
      value = t[1];
      ret = compare(str, value);
      if (ret === t[2]) {
        console.info('success', str, value, ret);
      } else {
        console.error('failed', str, value, ret);
      }
    }
    d0 = new Date();
    for (k = 0, len1 = testArr.length; k < len1; k++) {
      t = testArr[k];
      for (i = l = 1; l < 100000; i = ++l) {
        compare(t[0], t[1]);
      }
    }
    d1 = new Date();
    for (m = 0, len2 = testArr.length; m < len2; m++) {
      t = testArr[m];
      for (i = n = 1; n < 100000; i = ++n) {
        compare(t[0], t[1], false);
      }
    }
    d2 = new Date();
    return console.log('used cache:', d1 - d0, 'ms, not used cache:', d2 - d1, 'ms.');
  };

  if (/index/.test(process.argv[1])) {
    test();
    process.exit(-1);
  }

}).call(this);

//# sourceMappingURL=index.js.map
